#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options false
\language polish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 4
\paragraph_separation indent
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\align center

\series bold
Bielska Wyższa Szkoła
\begin_inset Newline newline
\end_inset

im.
 Józefa Tyszkiewicza 
\begin_inset Newline newline
\end_inset

w Bielsku-Białej
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3in
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/bwsb.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Praca Dyplomowa
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Michał Czyż
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Temat Pracy: Zwinne zarządzanie wymaganiami w procesie produkcji oprogramowania
\end_layout

\begin_layout Standard
\begin_inset VSpace 1.2in
\end_inset


\end_layout

\begin_layout Description
\paragraph_spacing single
Opiekun
\begin_inset space ~
\end_inset

pracy: dr.
 M.
 Smołka
\end_layout

\begin_layout Description
\paragraph_spacing single
Ocena
\begin_inset space ~
\end_inset

pracy:
\end_layout

\begin_layout Description
\paragraph_spacing single
Numer
\begin_inset space ~
\end_inset

albumu: 2288
\end_layout

\begin_layout Description
\paragraph_spacing single
Numer
\begin_inset space ~
\end_inset

ewidencyjny
\begin_inset space ~
\end_inset

pracy:
\end_layout

\begin_layout Standard
\begin_inset VSpace 1.2in
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Bielsko-Biała, 2009
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\align right
Bielsko-Biała dn.
 15 lutego 2009
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5in
\end_inset


\end_layout

\begin_layout Description
\paragraph_spacing single
Imię
\begin_inset space ~
\end_inset

i
\begin_inset space ~
\end_inset

nazwisko: Michał Czyż
\end_layout

\begin_layout Description
\paragraph_spacing single
Nr
\begin_inset space ~
\end_inset

albumu: 2288 
\end_layout

\begin_layout Description
\paragraph_spacing single
Wydział: Zarządzania i Informatyki 
\end_layout

\begin_layout Description
\paragraph_spacing single
Kierunek: Inżynieria Oprogramowania
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5in
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
OŚWIADCZENIE
\end_layout

\begin_layout Standard
Świadom odpowiedzialności prawnej oświadczam, że złożona praca inżynierska
 pt.: 
\series bold
Zwinne zarządzanie wymaganiami w procesie produkcji oprogramowania
\series default
 została napisana przeze mnie samodzielnie.
 
\end_layout

\begin_layout Standard
Równocześnie oświadczam, że praca ta nie narusza prawa autorskiego w rozumieniu
 ustawy z dnia 4 lutego 1994 roku o prawie autorskim i prawach pokrewnych
 (Dz.U.1994 nr 24 poz.
 83) oraz dóbr osobistych chronionych prawem cywilnym.
\end_layout

\begin_layout Standard
Ponadto praca nie zawiera informacji i danych uzyskanych w sposób nielegalny
 i nie była wcześniej przedmiotem innych procedur urzędowych związanych
 z uzyskaniem dyplomów lub tytułów zawodowych uczelni wyższej.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section
Wstęp
\end_layout

\begin_layout Standard
Właściwe pozyskiwanie informacji dotyczących wymagań od klienta, oraz ich
 dalsze przetwarzanie ma kluczowe znaczenie w procesie produkcji oprogramowania.
 Na to niełatwe zadanie wpływ ma wiele czynników.
 Jednym z powodów jest niejednolity język, którym posługują się klienci
 i developerzy.
 Zamawiający mają problem z artykułowaniem swoich oczekiwań, a developerzy
 często im w tym nie pomagają.
 Powstają w ten sposób systemy, które nie spełniają w pełni oczekiwań funkcjonal
nych, bądź są trudne w obsłudze, albo wręcz nie nadają się do jakiekolwiek
 zastosowania i lądują, mówiąc obrazowo, w koszu.
\end_layout

\begin_layout Standard
Problemy tego typu, stara się rozwiązać Inżynieria Oprogramowania.
 Na przełomie ostatnich 30 lat pojawiły się różne metodologie, czy też teorie,
 które porządkowały proces produkcji oprogramowania.
 Jednak, jak uargumentował Brooks w artykule 'No Silver Bullet - Essence
 and Accidents of Software Engineering'
\begin_inset CommandInset citation
LatexCommand cite
key "There.is.no.silver.bullet"

\end_inset

 z 1986 roku, nie ma i nie będzie srebrnej kuli, jeśli chodzi o metodologię
 zarządzania produkcją oprogramowania.
 Zwraca to naszą uwagę na fakt, że tworzenie oprogramowania jest trudne
 i wymaga czegoś więcej, niż formalnej struktury pracy, czy też listy kroków
 za którymi wystarczy podążać.
\end_layout

\begin_layout Standard
Pewne metodologie - np.: model kaskadowy - przez swoją niską skuteczność
 zostały już uznane przez wielu jako nieskuteczne
\begin_inset CommandInset citation
LatexCommand cite
key "AlanCooper.every.7.years,WaterfallDoesntWork"

\end_inset

.
 Jeśli coś nie spełnia swojej roli, zaczynają się poszukiwania i eksperymenty
 nad nowymi koncepcjami.
 Od lat siedemdziesiątych wiele się zmieniło, developerzy zrozumieli że
 narzędzia nie rozwiążą tego problemu, potrzebna jest natomiast zmiana w
 podejściu do klienta, która wymusza, aby był on członkiem zespołu projektowego.
 Dzięki czemu oprogramowanie będzie efektem silnej współpracy, której celem
 jest jak najlepszy produkt.
 Jednak aby to było możliwe, potrzeba wskazówek, którymi należy się kierować.
 Trzeba umieć uargumentować klientowi, że taki model współpracy da najlepsze
 efekty.
\end_layout

\begin_layout Standard
Pomiędzy 11 a 14 Lutego 2001 przedstawiciele
\begin_inset CommandInset citation
LatexCommand cite
key "AgileManifesto.Authors"

\end_inset

 wielu idei, takich jak extreme programming - Kent Beck, pragmatic programing
 - Dave Thomas, Andrew Hunt, SCRUM - Jeff Sutterland, crystal clear - Alistair
 Cockburn, adaptive software development - Jim Highsmith, oraz 11 innych
 doświadczonych programistów, którzy podpisali się pod 'Agile Manifesto'
\begin_inset CommandInset citation
LatexCommand cite
key "AgileManifesto"

\end_inset

.
 Zwrócili uwagę na cztery największe wartości, o których należy pamiętać
 w trakcie produkcji oprogramowania, a brzmi one następująco:
\end_layout

\begin_layout Quote
Poprzez wytwarzanie oprogramowania, oraz pomaganie innym w tym zakresie,
 odkrywamy lepsze sposoby realizowania tego zadania.
 W wyniku tych doświadczeń zaczęliśmy przedkładać: 
\end_layout

\begin_layout Quote

\emph on
Jednostki i współdziałania między nimi 
\emph default
nad procesy i narzędzia.
 
\end_layout

\begin_layout Quote

\emph on
Działające oprogramowanie
\emph default
 nad dokładną dokumentację.
 
\end_layout

\begin_layout Quote

\emph on
Współpracę z klientem
\emph default
 nad negocjację umów.
 
\end_layout

\begin_layout Quote

\emph on
Reagowanie na zmiany
\emph default
 nad realizowanie planu.
\end_layout

\begin_layout Quote
Oznacza to, że wprawdzie doceniamy to, co wymieniono po prawej stronie,
 jednak bardziej cenimy to, co znajduje się po lewej.
\begin_inset CommandInset citation
LatexCommand cite
key "AgileManifesto.Tlumaczenie"

\end_inset


\end_layout

\begin_layout Standard
Sam manifest przykuwa uwagę.
 Wskazuje, że bycie zwinnym
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Agile (zwinny), w pracy na przemian będzie używany oryginał oraz polskie
 tłumaczenie
\end_layout

\end_inset

 jest nacelowane na proces oraz ludzi, a nie na narzędzia i technologie.
 Aczkolwiek zrozumienie tego procesu, oraz wdrożenie go efektywnie, wymaga
 o wiele większej wiedzy.
 Prezentacja tej filozofii, wraz z przykładem użycia jej przy produkcji
 - zwłaszcza aplikacji webowych - jest jednym z celów tej pracy.
 
\end_layout

\begin_layout Standard
Drugim celem jest prezentacja narzędzia, które ma za zadanie wspierać proces
 pozyskiwania wymagań od klienta, udostępniając zaledwie trzy główne funkcjonaln
ości.
 A są to:
\end_layout

\begin_layout Itemize
przechowywać opowieści użytkownika
\end_layout

\begin_layout Itemize
udostępniać historie zmian dla tych opowieści użytkownika
\end_layout

\begin_layout Itemize
wspierać pisanie automatycznych testów integracyjnych
\end_layout

\begin_layout Standard
Dzięki tym trzem funkcjonalnościom, jest możliwe jasne zarządzaniem wymaganiami
 klienta, oraz wykazywanie jakie zmiany nastąpiły.
 Daje to obraz ilości pracy, która została wykonana dodatkowo, co umożliwi
 lepsze rozliczanie pracy.
 Kolejnym celem jest wykazanie, o ile lepszy jest efekt końcowy od pierwotnego
 - co wpłynie na zadowolenie klienta.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Streszczenie
\end_layout

\begin_layout Standard
W pierwszej części zostanie zwrócona uwaga na podstawy teoretyczne związane
 z zarządzaniem projektów.
 Krótko zostaną przedstawione metody tradycyjne, zwane też ciężkimi, takie
 jak model kaskadowy, czy też spiralny.
 Następnie zwrócona zostanie uwaga na metody zgodne z filozofią agile -
 potocznie zwane lekkimi.
 Kolejną sprawą będzie przedstawienie czterech wartości z manifestu agile,
 oraz uzupełniających ich zasad, wraz z praktycznymi przykładami.
 Zostaną wydzielone fazy produkcji oprogramowania - które są agile, a które
 fragile.
 Rozważone zostaną trzy główne metodologie związane z filozofią agile.
 Na koniec tej części nastąpi porównanie metod lekkich z ciężkimi.
\end_layout

\begin_layout Standard
Aby móc być zwinnymi podczas procesu produkcji oprogramowania, warto wybierać
 odpowiednie narzędzia, które się wybiera.
 Nie jest to niezbędne, aczkolwiek daje nam to większą efektywność w czasie
 pracy.
 Opisane zostaną wzorce projektowe, które stymulują podejmowanie właściwych
 decyzji, przy projektowaniu architektury systemu.
 Zwrócona zostanie uwaga, na dynamiczny i funkcyjny język jakim jest Ruby
\begin_inset CommandInset citation
LatexCommand cite
key "Ruby.homepage"

\end_inset

.
 Zostanie również omówione środowisko do budowy aplikacji webowych Ruby
 on Rails
\begin_inset CommandInset citation
LatexCommand cite
key "RoR.homepage"

\end_inset

.
 Następnie zwrócona będzie uwaga, na biblioteki wspierające pisanie automatyczny
ch testów, wraz z narzędziami do masowego tworzenia danych testowych.
\end_layout

\begin_layout Standard
Trzecią częścią będzie prezentacja koncepcji związanych z narzędziem wspomnianym
 na wstępie.
 Zaprezentowane zostaną wymagania dotyczące tego projektu, opisane za pomocą
 opowieści użytkownika - technika ta będzie opisana w sekcjach poświęconych
 BDD i Cucumber.
 Następnie zostanie zwrócona uwaga, na rozwiązania od strony technicznej,
 związane z tą aplikacją.
\end_layout

\begin_layout Standard
Ostatnim etapem będzie prezentacja samego narzędzia.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Zarządzanie projektem
\end_layout

\begin_layout Standard
Każda metodologia ma na celu ulepszenie procesu produkcji oprogramowania.
 Celem jest dostarczanie produktu, który spełni oczekiwania użytkownika
 końcowego.
 Model zarządzania powinien ułatwiać szacowanie czasu, potrzebnego na powstanie
 systemu, oraz kosztów, lub umożliwić wykonanie, jak największej ilości
 pracy w danym budżecie.
 Wymaga to pewnej formalizacji wymagań, oraz rejestrowania postępów, dzięki
 któremu developerzy wiedzą kiedy wszystko jest już zrobione.
 Zwrócona zostanie teraz uwaga na kilka takich modeli.
\end_layout

\begin_layout Subsection
Metody tradycyjne
\end_layout

\begin_layout Standard
Metody tradycyjne, zwane też ciężkimi, zawdzięczają taki przydomek ilości
 dokumentacji, która jest tworzona przed rozpoczęciem prac związanych z
 implementacją, często określane jako BDUF
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Big Design Up Front
\end_layout

\end_inset

.
 Argumentacją takiego podejścia, jest przeświadczenie, że solidna dokumentacja
 niesie ze sobą sukces projektu, oraz pozwala też uniknąć kosztów zmiany,
 gdyż zmiejsza prawdopodobieństwo pojawienia się zmian w trakcie implementacji.
 Zwróćmy uwagę na dwa najpopularniejsze modele.
\end_layout

\begin_layout Subsubsection
Model Kaskadowy
\end_layout

\begin_layout Standard
Model Kaskadowy
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Waterfall model - z języka angielskiego
\end_layout

\end_inset

 został opisany przez Winstona W.
 Royce w roku 1970 roku, w artykule 'Zarządzanie produkcją dużych systemów
 informatycznych'
\begin_inset CommandInset citation
LatexCommand cite
key "Waterfall.introduction"

\end_inset

.
 Choć on sam nie użył tej nazwy, jest to jednak najbardziej znany dokument
 opisujący ten model.
 Royce w żadnym wypadku nie chwali takiego podejścia, a raczej je krytykuje,
 jako nieskutecznie i nieefektowne.
 Głównym założeniem tej metodologi, jest podział produkcji oprogramowania
 na sześć niepodzielny faz:
\end_layout

\begin_layout Itemize
Specyfikacja wymagań funkcjonalnych
\end_layout

\begin_layout Itemize
Analiza systemu
\end_layout

\begin_layout Itemize
Modelowanie systemu, rozwiązań
\end_layout

\begin_layout Itemize
Implementacja
\end_layout

\begin_layout Itemize
Testy jednostkowe, oraz integracyjne
\end_layout

\begin_layout Itemize
Wdrożenie i pielęgnacja systemu
\end_layout

\begin_layout Standard
Przejście do kolejnej fazy, jest możliwe tylko i wyłącznie po ukończeniu
 aktualnej.
 Jeżeli na kolejnym etapie pojawią się problemy związane z niedopatrzeniami
 w którejś z poprzednich faz, należy wrócić do tego momentu, i wykonać jeszcze
 raz wszystkie etapy w kolejności, aż do skutku.
 Oprogramowanie jest wdrażane, gdy ostatnia faza da zadowalający efekt,
 jest to zazwyczaj długi okres czasu, około jednego roku.
\end_layout

\begin_layout Subsubsection
Model Spiralny
\end_layout

\begin_layout Standard
Model spiralny
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Spiral Model - z języka angielskiego
\end_layout

\end_inset

, zdefiniował Barry Boehm, w artykule 'Model Spiralny w produkcji oprogramowania
 i usprawnienia'
\begin_inset CommandInset citation
LatexCommand cite
key "SpiralModel.introduction"

\end_inset

 z 1988 roku.
 Boehm podzielił proces produkcji oprogramowania na cztery iteracyjne fazy:
\end_layout

\begin_layout Itemize
Specyfikowanie systemu wraz z detalami, ustalenie celów
\end_layout

\begin_layout Itemize
Analiza ryzyka oraz prototypy
\end_layout

\begin_layout Itemize
Implementacja, zawierająca 
\end_layout

\begin_deeper
\begin_layout Itemize
przygotowanie szczegółowych koncepcji
\end_layout

\begin_layout Itemize
programowanie
\end_layout

\begin_layout Itemize
integrowanie z istniejąca częścią systemu
\end_layout

\begin_layout Itemize
testowanie
\end_layout

\begin_layout Itemize
odbiór
\end_layout

\end_deeper
\begin_layout Itemize
Analiza zakończonej iteracji i planowanie następnej
\end_layout

\begin_layout Standard
Specyfikacja modelu iteracyjnego, nie narzuca jedynie takich etapów w fazie
 trzeciej, można tutaj użyć również modelu kaskadowego.
 Każda iteracja jest swego rodzaju samodzielna, może rozpocząć się na już
 prowadzonym projekcie, a po jej zakończeniu wszystkie zmiany, które miały
 zostać osiągnięte, są wdrożone w działający system.
 Zazwyczaj iteracja trwa od jednego do trzech miesięcy, a więc jest krótsza
 niż w modelu kaskadowym
\end_layout

\begin_layout Subsection
Filozofia Agile
\end_layout

\begin_layout Standard
Jak wykazano we wstępnie filozofia agile jest inna.
 Jako pierwsza, kieruje uwagę na dostosowywanie się do konkretnego projektu
 klienta, i bycie elastycznym.
 Bardzo klarowny jest przekaz manifestu agile ( wartości które są najistotniejsz
e, wymienione są jeszcze raz poniżej).
 Poniżej 12 zasad które uzupełniają sam manifest.
\end_layout

\begin_layout Standard
\align center

\series bold
Największe wartości Agile
\end_layout

\begin_layout Quote
\align center

\emph on
Jednostki i współdziałania między nimi
\emph default
 
\end_layout

\begin_layout Quote
\align center

\emph on
Działające oprogramowanie
\end_layout

\begin_layout Quote
\align center

\emph on
Współpraca z klientem
\end_layout

\begin_layout Quote
\align center

\emph on
Reagowanie na zmiany
\end_layout

\begin_layout Standard
\align center

\series bold
Zasady Agile
\begin_inset CommandInset citation
LatexCommand cite
key "AgileManifesto.Principles"

\end_inset


\end_layout

\begin_layout Quote
\align center
Najważniejsze jest zadowolenie klienta 
\begin_inset Newline newline
\end_inset

poprzez wczesne i ciągłe dostarczanie wartościowego oprogramowania.
\end_layout

\begin_layout Quote
\align center
Zmiany w wymaganiach są mile widziane, nawet na późnym
\begin_inset Newline newline
\end_inset

 etapie prac.
 Proces agile radzi sobie ze zmianą 
\begin_inset Newline newline
\end_inset

przez wzgląd na korzyść dla klienta.
\end_layout

\begin_layout Quote
\align center
Dostarczać działający system często, 
\begin_inset Newline newline
\end_inset

czy to co kilka tygodni, czy też miesięcy, 
\begin_inset Newline newline
\end_inset

z naciskiem na krótsze okresy.
\end_layout

\begin_layout Quote
\align center
Ludzie biznesu i developerzy muszą codziennie 
\begin_inset Newline newline
\end_inset

pracować razem, przez cały okres trwania projektu.
\end_layout

\begin_layout Quote
\align center
Prace na projektem należy połączyć z motywacją jednostek.
 
\begin_inset Newline newline
\end_inset

Zapewnij im odpowiednie środowisko pracy, oraz wsparcie jakiego potrzebują.
 
\begin_inset Newline newline
\end_inset

Obdarz ich zaufaniem, że wykonają pracę jak należy.
\end_layout

\begin_layout Quote
\align center
Najbardziej wydajną i efektowną metodą 
\begin_inset Newline newline
\end_inset

przekazu informacji dla zespołu oraz dla klienta
\begin_inset Newline newline
\end_inset

jest rozmowa twarzą w twarz.
\end_layout

\begin_layout Quote
\align center
Główną miarą postępu jest działające oprogramowanie.
\end_layout

\begin_layout Quote
\align center
Proces Agile promuje ciągły niczym nieprzerwany proces 
\begin_inset Newline newline
\end_inset

rozwoju systemu.
 Inwestorzy, developerzy oraz użytkownicy powinni 
\begin_inset Newline newline
\end_inset

zabiegać o ciągłe utrzymywanie stałego tempa pracy.
\end_layout

\begin_layout Quote
\align center
Zwracanie ciągłej uwagi na techniczny kunszt 
\begin_inset Newline newline
\end_inset

oraz dobre projektowanie, wspiera bycie zwinnym.
\end_layout

\begin_layout Quote
\align center
Prostota - czyli sztuka maksymalizacji ilości pracy, 
\begin_inset Newline newline
\end_inset

niewykonanej - to podstawa.
\end_layout

\begin_layout Quote
\align center
Najlepsze architektury, wymagania oraz projekty 
\begin_inset Newline newline
\end_inset

pochodzą od zespołów które same sobą zarządzają.
\end_layout

\begin_layout Quote
\align center
W równych odstępach czasowych, zespół analizuje w jaki 
\begin_inset Newline newline
\end_inset

sposób mógłby stać się bardziej efektywny, a następnie dostosowywuje się
 do własnych spostrzeżeń.
\end_layout

\begin_layout Standard
Powyższe zasady i wartości warto mieć zawsze w pamięci, jeśli chcemy pozostać
 w z zgodzie z filozofią agile.
 Na podstawie tych reguł, powstało wiele zasad i metodologii, które wdrażane,
 wraz z dostosowaniem do możliwości zespołu i charakteru projektu, daję
 dobre efekty.
\end_layout

\begin_layout Subsubsection
Reguły usprawniające proces
\end_layout

\begin_layout Standard
Reguły wymienione poniżej są bardzo proste, ale tylko gdy dobrze je zrozumiemy
\end_layout

\begin_layout Paragraph
Nie powtarzaj się
\end_layout

\begin_layout Standard
Druga zasada Agile, traktuje zmiany, jako mile widziane na każdym etapie
 pracy, nawet na tym bardzo zaawansowanym.
 Wymaga to częstych zmian w kodzie źródłowym.
 Jedną z zasad, która ułatwia taki cykl obróbki kodu - czasem wręcz tylko
 dzięki stosowaniu się do niej jest to możliwe - jest unikanie duplikacji
 kodu.
 Pomocna przy tym jest reguła DRY
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Don't Repeat Yourself, znana również jako Single Point of Truth.
 Popularny akronim DRY
\end_layout

\end_inset

, przez wielu odczytywana jako unikanie powtórzeń w kodzie.
 Jak zwrócił uwagę Dave Thomas
\begin_inset CommandInset citation
LatexCommand cite
key "DRY.Interview.With.Dave.Thomas"

\end_inset

 to nie jest prawdziwy cel tej reguły - jej sednem jest, aby każda część
 wiedzy - zachowania - systemu miała jedną autorytatywną i jednoznaczną
 reprezentację.
 Wiedza na temat systemu, jak zwrócił uwagę w wywiadzie, wychodzi ponad
 sam kod aplikacji, dotyczy ona schematu baz danych, kwestii testów, a nawet
 dokumentacji.
 Czasem, aby móc osiągnąć taki stan, potrzebne są generatory kodu wiążące
 się z zaawansowanymi technikami meta-programowania, lecz właśnie dzięki
 stosowaniu się to tej reguły jesteśmy w stanie uzyskać elastyczny i dający
 się pielęgnować system.
\end_layout

\begin_layout Paragraph
Najprostsza rzecz, która działa
\end_layout

\begin_layout Standard
Istotą tej reguły jest jak najszybsze pokazanie efektu pracy klientowi.
 Jeżeli uprościmy pierwszą wersję projektu, uzyskanie efektu jest szybsze.
 Jest to jak najbardziej zgodne z pierwszą, trzecią oraz siódmą zasadą manifestu
 agile.
 Pokazywanie klientowi często tego, co zostało zrobione, stymuluje potrzebne
 zmiany w systemie, które bez wizualnej prezentacji zostałyby pominięte,
 czy też zepchnięte na dalszy plan.
\end_layout

\begin_layout Paragraph
Naprawdę tego nie potrzebujesz
\end_layout

\begin_layout Standard
Czasem zdarza się, że tworzymy nowe klasy, metody nie zastanawiając się,
 czy aby na pewno tego naprawdę potrzebujemy w tej chwili.
 Bądź też piszemy kod, z myślą o przyszłych ewentualnych udogodnieniach,
 które mogłyby mieć miejsce, jeśli trzeba będzie zrobić to, lub owo.
 Związane jest z tym wiele wątpliwości.
 Reguła
\begin_inset CommandInset citation
LatexCommand cite
key "You.not.gonna.need.it"

\end_inset

 silnie nawołuje, aby kodować tylko funkcjonalności rzeczywiste, te które
 są ważne, i dlatego warto zadać sobie samemu pytanie 
\begin_inset Quotes sld
\end_inset

Czy aby na pewno tego potrzebuję?
\begin_inset Quotes srd
\end_inset

, zamiast mechanicznie klepać kod.
 Drugą sprawą, na którą zwraca ona uwagę, to fakt, że w momencie gdy zaczynamy
 rozwodzić się nad przyszłymi udogodnieniami, tracimy z oczu główny cel.
\end_layout

\begin_layout Paragraph
Iteracyjny proces wytwarzania
\end_layout

\begin_layout Standard
Aby często dostarczać działający system, potrzeba podzielić proces tworzenia
 systemu, na małe kawałki, z których każdy dostarcza biznesową wartość dla
 systemu.
 XP
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
skrót - Extreme Programing
\end_layout

\end_inset

 preferuje przyjąć jako jednostkę tydzień, Scrum dwa.
 Lecz nie jest to sztywną regułą, warto dostosować jednostkę do swoich możliwośc
i.
 Jednakże nacisk jest kładziony na krótkie okresy.
\end_layout

\begin_layout Paragraph
Scrum
\end_layout

\begin_layout Standard
W 1986 roku Hirotaka Takeuchi wraz Ikujiro Nonaka, opisali całkowicie nową,
 koncepcję zarządzania projektami informatycznymi.
 Położyli w nim nacisk, na postęp całej drużyny, współdziałającej razem
 nad wspólnymi celami.
 W 1991 roku DeGrace i Stahl, jako pierwsi odnieśli się to tej metodologi,
 która funkcjonuje pod nazwą Scrum.
\end_layout

\begin_layout Standard
Idea Scrum'a
\begin_inset CommandInset citation
LatexCommand cite
key "scrum.10.steps"

\end_inset

 wychodzi z założenia, że na początku realizacji projektu, mamy ogólny obraz
 właściwości, które musi posiadać dany system.
 Zestawienie tych cech, nazywane jest listą właściwości produktu
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
produkt backlog(ang.)
\end_layout

\end_inset

.
 Lista ta, powinna być posortowana według biznesowej wartości.
 Powinna być też wydzielona część, na właściwości krytyczne, oraz tak zwaną
 listę życzeń.
 Kolejnym etapem jest pogrupowanie - biorąc pod uwagę ich priorytety - celów,
 i wydzielenie ram czasowych, dla każdej z grup - okresy te nazywamy sprintami.
 
\end_layout

\begin_layout Standard
Każdy sprint posiada własną listę właściwości, która jest już bardziej szczegóło
wa.
 Każdy element listy posiada swój priorytet, dzięki czemu wiadomo jaka jest
 kolejność wykonywania zadań.
 Może ona zawierać także właściwości opcjonalne, choć nie jest to konieczne.
 Sprint trwa od dwóch tygodni do miesiąca.
 Zadania, które estymowane są na więcej niż 16 godzin, powinny być podzielone.
 
\end_layout

\begin_layout Standard
Najpóźniej - jeśli to możliwe, można wcześniej - na koniec sprinta, wszystkie
 właściwości z backloga, muszą być gotowe do użycia.
 Dzięki temu możliwe jest zebrania reakcji od użytkowników.
 Ich uwagi są brane pod uwagę przy następnym sprincie, lub jeśli czas pozwala
 - w tym samym.
\end_layout

\begin_layout Standard
W ramach sprintu każdy dzień rozpoczyna się od krótkiego - około piętnastominuto
wego - spotkania, w którym uczestniczą wszyscy członkowie zespołu.
 Każdy odpowiada na trzy pytania:
\end_layout

\begin_layout Itemize
Co udało mi się zrobić w dniu wczorajszym?
\end_layout

\begin_layout Itemize
Co planuje zrobić dziś?
\end_layout

\begin_layout Itemize
Na jakie przeszkody natrafiłem?
\end_layout

\begin_layout Standard
Dzięki temu cały zespół wie, jakie zmiany następują w systemie, oraz daje
 to możliwość szybszego rozwiązywania przeszkód, dzięki spojrzeniu na problem
 z wielu perspektyw.
\end_layout

\begin_layout Standard
Rozwój projektu jest mierzony za pomocą 'tablic postępu'
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
burnout chart(ang.)
\end_layout

\end_inset

.
 Jest ona osobna dla całego projektu (poszczególnych właściwości), oraz
 dla poszczególnych sprintów.
 Jako skali używa się czasem liczb pierwszych, lub liczb z ciągu Fibonacciego.
\end_layout

\begin_layout Paragraph
Behavior Driven Development
\end_layout

\begin_layout Standard
BDD jest techniką organizacji produkcji oprogramowania, która kładzie duży
 nacisk na współpracę, pomiędzy programistami, a ludźmi związanymi z biznesem
 - tymi, którzy zamawiają system, jak również z tymi, którzy będą go używać.
 Jest to zgodne z filozofią agile.
 Dan North
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://dannorth.net/ - oficjalny blog
\end_layout

\end_inset

 zaprezentował po raz pierwszy tą koncepcję, w 2003 roku
\begin_inset CommandInset citation
LatexCommand cite
key "BDD.Author.Introduction"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
http://www.flickr.com/photos/obie/421149993/
\end_layout

\end_inset

.
 Jak sama nazwa wskazuje, zachowanie systemu jest najważniejszą kwestią
 w trakcie produkcji.
 Autor zwrócił szczególną uwagę na kwestię wartości biznesowej, którą wniesie
 implementacja konkretnego zachowanie w systemie - gdyż to jest najważniejsze
 z punktu widzenie użytkowników systemu.
 Ciekawe jest też jego podejście jak determinować, którą rzecz powinniśmy
 implementować.
 Sugeruje, że powinniśmy sobie zadać pytanie 'Jaka jest kolejna najważniejsza
 cecha, której system nie posiada?'.
 Wydaje się to banalne, aczkolwiek przynosi najlepsze rezultaty dla inwestorów,
 a zwłaszcza końcowych użytkowników.
 W przypadku korzystania ze Scrum'a jest to dobra reguła dla ustawiania
 priorytetów w backlog'u.
\end_layout

\begin_layout Standard
Zgodnie z tym, Dan North przed stawił
\begin_inset CommandInset citation
LatexCommand cite
key "BDD.info"

\end_inset

 trzy główne założenia BDD, którym przyjrzymy się teraz dokładniej.
 
\end_layout

\begin_layout Subparagraph
Najważniejszy jest opis zachowania systemu
\begin_inset CommandInset citation
LatexCommand cite
key "BDD.AllAboutBehaviour"

\end_inset


\end_layout

\begin_layout Standard
Ta reguła zwraca uwagę, iż najważniejsze jest to, aby wiedzieć jak system
 ma się zachować i jakie funkcjonalności ma udostępniać dla użytkownika.
 Zapis funkcjonalności w ten sposób - opis, zachowanie - jest uwarunkowany
 potrzebą jednoznacznego rozumienia słów - efektu jaki mają mieć na system
 - tak, aby programiści, oraz ludzie związani z biznesem wzajemnie się rozumieli.
 Wykorzystuje się do tego celu opowieści użytkownika, które są narracją
 interakcji użytkownika z systemem, a które dokładniej zostaną omówione
 później.
\end_layout

\begin_layout Subparagraph
System udostępnia pewne zachowanie, ponieważ wnosi ono wartość dla biznesu
\begin_inset CommandInset citation
LatexCommand cite
key "BDD.BusinessValue"

\end_inset


\end_layout

\begin_layout Standard
Dosyć częstym błędem jest występowanie w systemie nowych funkcjonalności,
 bądź użycie nowych technologii, tylko dlatego, że sprawiają wrażenie interesują
cych.
 Jest to pewnego rodzaju patologia, występująca w produkcji oprogramowania.
 Zwrócenie uwagi na wartość biznesową, ma ogromny wpływ na efektywność,
 oraz koszt związany z systemem, choć zazwyczaj nie jest to sprawa oczywista
 ani, na co zwraca uwagę North, nie jest to postrzegane jako rzecz niezbędna.
\end_layout

\begin_layout Subparagraph
Opierać się na wiedzy, a nie przewidywaniach
\begin_inset CommandInset citation
LatexCommand cite
key "BDD.EnoughIsEnough"

\end_inset


\end_layout

\begin_layout Standard
Domena metodologi BDUF zakłada, że jesteśmy w stanie zapisać wszystkie informacj
e na temat systemu, przed rozpoczęciem jego realizacji.
 Innymi słowy, jesteśmy w stanie przewidzieć wszystko, na temat systemu
 - jednak bardzo często tak nie jest.
 Warto zwrócić uwagę na fakt, że im dłuższy okres chcemy przewidzieć, oraz
 im bardziej złożony jest problem, tym większe prawdopodobieństwo, iż nasze
 założenia będą błędne.
 Taka postawa - posiadania wiedzy na początku - wynika również z obawy przed
 potencjalnym kosztem zmiany, a menadżerowie są w tym wypadku najlepszym
 przykładem.
 BDUF się nie sprawdziło, gdyż zmiany zawsze się pojawiają.
 BDD z założenia zabrania modelowania systemu przez zgadywania, a minimalizacja
 kosztu zmian jest uzyskiwana poprzez utrzymanie technicznie systemu w taki
 sposób, aby łatwo można było w nim zmiany wprowadzać.
 W sekcji Filozofia Agile zwrócono uwagę na metodologie, które to umożliwiają,
 takie jak iteracyjny proces produkcji - najprostsza rzecz, która działa,
 oraz nie implementowanie funkcjonalności, które nie są wymagane.
\end_layout

\begin_layout Subparagraph
Opowieści użytkownika
\end_layout

\begin_layout Standard
North zwraca uwagę na trzy części, które występują w opowieści
\end_layout

\begin_layout Itemize
tytuł, który jednoznacznie determinuje zakres serwowanych funkcjonalności
 w systemie
\end_layout

\begin_layout Itemize
krótki opis tego, co jest celem danej funkcjonalności i dlaczego ją wprowadzamy
\end_layout

\begin_layout Itemize
warunki akceptacji, które definiuje kiedy funkcjonalność w systemie jest
 w pełni zaimplementowana, są one w formie scenariuszy
\end_layout

\begin_layout Subparagraph
Przykład:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/code/Cucumber.example.png

\end_inset


\end_layout

\begin_layout Subparagraph
Automatyczne testowanie zachowania systemu
\end_layout

\begin_layout Standard
Celem BDD jest wymuszenie współpracy z klientem, oraz polepszenie z nim
 komunikacj, poprzez stosowanie języka, które obie strony rozumieją.
 Efektem takiej pracy jest specyfikacja w postaci historyjek użytkownika,
 które to umożliwiają pisanie automatycznych testów akceptacji, dzięki czemu
 jest możliwa lepsza weryfikacja poprawności zachowania systemu.
 Dużym błędem
\begin_inset CommandInset citation
LatexCommand cite
key "BDD.BehaviourDrivenPrograming"

\end_inset

, który popełniano podczas TDD
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Test-Driven-Development
\end_layout

\end_inset

 było zbyt dokładne testowanie kodu, a nie zachowania systemu, co utrudniało
 zmiany, zamiast je stymulować
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Ludzie z kręgu BDD, nie zalecają pisania testów dla metod prywatnych, i
 chronionych
\end_layout

\end_inset

.
 Dlatego tak ważne jest, aby pisać testy, które weryfikują zachowanie systemu,
 bądź poszczególnych komponentów.
 Tak też narodził się pomysł, aby przygotować narzędzia wspierające ten
 proces.
 W 2003 roku Dan postanowił zastąpić JUnit, własną biblioteką, która ułatwiała
 by pisanie testów zachowania i nazwał ją JBahave.
 Na przełomie ostatnich pięciu lat powstało wiele odpowiedników, bądź też
 rozszerzeń dla poszczególnych języków.
 Poniżej lista.
\end_layout

\begin_layout Description
.NET NBehave
\begin_inset CommandInset citation
LatexCommand cite
key "NBehave"

\end_inset

, NSpec
\begin_inset CommandInset citation
LatexCommand cite
key "NSpec"

\end_inset

, NSpecify
\begin_inset CommandInset citation
LatexCommand cite
key "NSpecify"

\end_inset

, NUnit
\begin_inset CommandInset citation
LatexCommand cite
key "NUnit"

\end_inset

, Cucumber
\begin_inset CommandInset citation
LatexCommand cite
key "Cucumber.wiki"

\end_inset


\end_layout

\begin_layout Description
Java Instinct
\begin_inset CommandInset citation
LatexCommand cite
key "instinct"

\end_inset

, JBehave
\begin_inset CommandInset citation
LatexCommand cite
key "JBehave"

\end_inset

, JDave
\begin_inset CommandInset citation
LatexCommand cite
key "JDave"

\end_inset

, Cucumber
\end_layout

\begin_layout Description
JavaScript JSSpec, JSpec
\begin_inset CommandInset citation
LatexCommand cite
key "Jspec"

\end_inset


\end_layout

\begin_layout Description
C CSpec
\begin_inset CommandInset citation
LatexCommand cite
key "CSpec"

\end_inset


\end_layout

\begin_layout Description
Scala Specs
\begin_inset CommandInset citation
LatexCommand cite
key "Specs"

\end_inset


\end_layout

\begin_layout Description
Ruby Rspec
\begin_inset CommandInset citation
LatexCommand cite
key "Rspec.homepage"

\end_inset

, Cucumber
\end_layout

\begin_layout Standard
W kolejnej sekcji zostanie omówiona biblioteka RSpec, ze względu na użycie
 języka Ruby w projekcie, oraz biblioteka Cucumber, która daje możliwość
 uruchamiania opowieści użytkownika jako wykonywalnego kodu, przez co jest
 niezwykle użyteczna.
 Narzędzie które jest opisane w sekcji piątej, wspiera prezentację informacji
 w tym formacie.
\end_layout

\begin_layout Subsection
Dlaczego Agile
\end_layout

\begin_layout Standard
Metodologie zwinne nie są wymysłem ostatnich lat
\begin_inset CommandInset citation
LatexCommand cite
key "WaterfallDoesntWork"

\end_inset

, a jednak popularność ich zaczęła wzrastać w połowie lat dziewięćdziesiątych.
 Co więcej, model kaskadowy jest ciągle w użyciu.
 Powodem takiej sytuacji, jest zapewne zatwierdzenie modelu kaskadowego,
 jako standardu dla projektów informatycznych przez DoD
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Departament Obrony Narodowej Stanów Zjednoczonych
\end_layout

\end_inset

, a następnie przyłączyło się do tego NATO.
 Royce - który jako jeden z pierwszych dokonał analizy tej metodologi -
 opisał dokładnie ten proces w latach siedemdziesiątych - w artykule 'Zarządzani
e produkcją dużych systemów informatycznych', i podał go jako przykład negatywny.
 Zwrócił uwagę na jego niską skuteczność, oraz ogromne koszty.
\end_layout

\begin_layout Standard
Jeff Sutherland w artykule 'Czego mnie nauczył pierwszy Scrum'
\begin_inset CommandInset citation
LatexCommand cite
key "SCRUM.what.i.learned"

\end_inset

, zapisał cztery spostrzeżenia na temat metodologi kaskadowych względem
 Scrum'a:
\end_layout

\begin_layout Itemize
nie jest w stanie przewidzieć wszystkiego na początku
\end_layout

\begin_layout Itemize
nie jest w stanie dostarczyć projektu na czas
\end_layout

\begin_layout Itemize
jest mniej efektywna - mniejsza ilość funkcjonalności na jednostkę czasu
 programisty
\end_layout

\begin_layout Itemize
wrażenie użytkownika jest niezadowalające
\end_layout

\begin_layout Standard
Metodologia Agile zamiast walczyć z problem uzyskania całkowitej wiedzy
 na początku, stara się radzić z tą niewiedzą - bo jest to naturalne, że
 nie da się na początku wszystkiego ustalić.
 To samo tyczy się zmian, które wynikają w okresie produkcji - są one nawet
 traktowane, jako coś pożądanego.
 A skoro użytkownicy potrafią sprecyzować czego oczekują od systemu, gdy
 zobaczą jego początkową wersję, warto ją pokazać jak najwcześniej, i często.
 Zwinne zarządzanie projektem stara się wkomponować w proces, który daje
 klientowi dużą kontrolę nad kształtem systemu, i to na każdym etapie prac,
 a nie tylko na etapie wstępnej specjalizacji.
 Jest to ważny elemen, który przyczynia się do zadowolenia z wyprodukowanego
 oprogramowania - co potwierdza skuteczność tej metody.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Technologie i wzorce projektowe
\end_layout

\begin_layout Standard
Choć metodologia agile nie jest związana z konkretnymi technologiami, to
 jednak języki, oraz środowiska dające się łatwo re-faktorować są korzystniejsze.
 Stosowanie się do odpowiednich wzorców, stymuluje pisanie dobrego kodu,
 dzięki czemu zmiany w takim systemie są efektywniejsze, i łatwiej taki
 system sprzężyć z innym.
 Jest to efekt filozofii jaką agile ma do zmian, i musimy być na nie ciągle
 otwarci.
 Zmiany ze strony klienta są nieuniknione, a mówiąc bardziej precyzyjnie
 są niezbędne aby produkt był wartościowy.
 Wpływ na to ma również użytkownik końcowego produktu, którego uwagi mogą
 podnieść znacznie używalność systemu, niestety informacje takie docierają
 późno.
 Czasem sami developerzy zauważają pewne nieprawidłowości i decydują się
 na zmiany.
 Wymaga to, aby kod był dobrze utrzymany, bez redundantności, przejrzysty
 i jednoznaczny.
 Poniżej zwrócę uwagę na sprawdzone wzorce, które pomagają osiągnąć ten
 cel.
\end_layout

\begin_layout Subsection
Model-Widok-Kontroler
\end_layout

\begin_layout Standard
Wzorzec MVC
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Model-View-Controller
\end_layout

\end_inset

 ma już za sobą prawie 30 lat, a został opracowany przez norwega Trygve
 Renskauga na Uniwersytecie w Oslo na przełomie lat 1978-79.
 Pierwotna nazwa brzmiała THING-MODEL-VIEW-EDITOR, końcową nazwę zawdzięczamy
 dyskusji autora z Adele Goldberg, dzięki której 10 grudnia 1979, przyjęto
 ostateczną nazwę.
 O samej przyczynie zaistnienia tego wzorca, sam autor mówi: 'MVC powstało
 jako naturalne rozwiązanie dla powszechnego problemu dostarczenia użytkownikom
 kontroli nad ich własnymi danymi z wielu perspektyw'
\begin_inset CommandInset citation
LatexCommand cite
key "MVC.Author.Report"

\end_inset

.
 Wskazuje to na idee obdzielenia samych danych i sposobu ich prezentacji
 oraz modyfikacji, co jest logiczne.
 Zwróćmy uwagę dokładniej na poszczególne elementy oraz interakcje między
 nimi.
 
\end_layout

\begin_layout Paragraph
Model
\end_layout

\begin_layout Standard
Model jako abstrakcyjna forma, reprezentacja encji, jest ważnym aspektem
 izolacji.
 Cześć systemu kwalifikowaną jako model, można przedstawić jako zestaw atrybutów
, które ona przechowuje, oraz logikę biznesową, która jednoznacznie określa
 zachowanie.
 Zgodnie z definicją wzorca, model nie ma bezpośredniego dostępu do kontrolera
 czy widoku.
 Jeśli próby przechowywanie atrybutów poza modelem wydają się dziwne i rzadko
 spotykane, to umieszczanie logiki w kontrolerach, czy też widokach jest
 dosyć powszechną patologią, która powoduje duże problemy w momencie prób
 optymalizacji, czy też pielęgnacji kodu.
 Doświadczenie pokazuje, że trzymanie się ściśle tych prostych dwóch reguł,
 wymusza większy porządek w implementacji systemu.
 Łatwiej wtedy jest uniknąć redundancji kodu, oraz optymalizacja kodu jest
 mniej ryzykowna.
 Ma to duże znaczenie zwłaszcza w aplikacjach webowych, gdzie mnogość form
 prezentacji danych, wymaga jednoznacznie określonej logiki na poziomie
 modelu.
\end_layout

\begin_layout Paragraph
Widok
\end_layout

\begin_layout Standard
Widok jest odpowiedzialny za reprezentację wizualną danych, oraz interfejsów
 edycyjnych.
 Pierwotna definicja
\begin_inset CommandInset citation
LatexCommand cite
key "MVC.Author.Report"

\end_inset

 zakładała, że widok jest bezpośrednio powiązany z modelem.
 The Passive View Pattern zakłada, że widok ma dostęp do modelu, tylko za
 pomocą kontrolera - nie występuje bezpośrednie odwołanie do modelu.
 Widok, który operuje tylko na danych przygotowanych przez kontroler jest
 dużo prostszy, a ponieważ wszelkie dane przechodzą przez kontroler, programista
 ma nad nimi większą kontrolę.
 Ta odmiana wzorca, jest promowana w aplikacjach webowych.
 Jedyna logika jaka może występować w widoku, to ta związana z kontrolkami,
 których zachowanie nie jest bezpośrednio związane z logiką biznesową.
\end_layout

\begin_layout Paragraph
Kontroler
\end_layout

\begin_layout Standard
Kontroler ma spełniać dwa proste zadania, przyjąć komunikat od użytkownika
 i przygotować dane zwrotne.
 W kwestii pierwszej funkcjonalności, rolą kontrolera jest, aby przyjąć
 informacje od użytkownika, przekazać komunikat razem z danymi do odpowiedniego
 modelu, przyjąć wynik który model zwrócił, a przygotowane dane przesłać
 do odpowiedniego widoku.
 Dodatkowo dochodzą kwestie takie jak uwierzytelnienie użytkownika, oraz
 kwestie własności do obiektów.
\end_layout

\begin_layout Standard
Pilnowanie, aby nie wychodzić poza kompetencje, owocuje dużą niezależnością
 poszczególnych komponentów, oraz możliwością rozwoju aplikacji bez naruszania
 wcześniejszych elementów.
\end_layout

\begin_layout Subsection
Representational state transfer
\end_layout

\begin_layout Standard
REST jest stylem projektowania interfejsów w systemach rozproszonych takich
 jak globalna sieć.
 Samo pojęcie zostało wprowadzone w 2000 roku przez Roy T.
 Fieldinga
\begin_inset CommandInset citation
LatexCommand cite
key "REST.roy.t.fielding.homepage"

\end_inset

.
 Warto wspomnieć, że jest on jednocześnie jednym z głównych autorów protokołu
 HTTP, oraz współtwórcą Apacha
\begin_inset CommandInset citation
LatexCommand cite
key "ApacheFoundation"

\end_inset

.
\end_layout

\begin_layout Standard
Najważniejszą regułą jest projektowanie systemu z zewnątrz, (z publicznych
 interfejsów), poprzez wydzielenie zasobów
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
resource, w języku angielskim
\end_layout

\end_inset

.
 Zasób jest to źródło informacji o danym charakterze i musi być określone
 przez rzeczownik nigdy przez czasownik.
 Przykładem zasobu może być profil użytkownika w danym serwisie, daje on
 najczęściej możliwość pobierania informacji oraz manipulowania.
 Każdy zasób musi posiadać unikalny identyfikator, dla protokołu HTTP jest
 to URI
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Uniform Resource Identifier
\end_layout

\end_inset

.
 Bardzo często w aplikacjach webowych, jeden zasób potrafi prezentować te
 same dane w różnych formatach.
 W postaci HTML lub w formacie XML lub JSON dla różnego typu kontrolek javascrip
towych czy też RSS, ATOM dla czytników wiadomości.
\end_layout

\begin_layout Standard
Kolejną istotną sprawą jest kwestia minimalizacji metod w zasobie, czyli
 tak naprawdę ilości komunikatów, na które odpowiadają.
 Z założenia należy się ograniczyć do maksymalnie siedmiu metod.
 Cztery z nich są związane z operacjami na pamięci stałej
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
często określane akronimem CRUD(Create,Read, Update, Delete)
\end_layout

\end_inset

, a są to metody:
\end_layout

\begin_layout Itemize
Utwórz
\end_layout

\begin_layout Itemize
Odczytaj
\end_layout

\begin_layout Itemize
Uaktualnij
\end_layout

\begin_layout Itemize
Usuń
\end_layout

\begin_layout Standard
Kolejne dwie metody związane są z ułatwieniem operacji edycyjnych:
\end_layout

\begin_layout Itemize
Nowy - wspiera tworzenie interfejsu, oraz tworzenie nowych instancji zasobu
\end_layout

\begin_layout Itemize
Edycja - przygotowuje interfejs z wczytanymi danymi istniejącej instancji
 zasobu
\end_layout

\begin_layout Standard
Siódma metoda służy do pobierania z zasobu kolekcji instancji, często jest
 określana mianem indeks lub lista.
\end_layout

\begin_layout Standard
Wyjście ponad siedem akcji jest dopuszczalne tylko w szczególnych przypadkach.
 Jeśli w systemie występuje średnio więcej niż półtora akcji na zasób, sugeruje
 to możliwy błąd związany ze sposobem ich zaprojektowaniem.
\end_layout

\begin_layout Standard
Wielką zaletą projektowania systemu zgodnie z tymi zasadami, jest przejrzysta
 możliwość interakcji między różnymi aplikacjami.
 Platforma taka jak Rails posiada osobny moduł - ActiveResource - wspierający
 podpięcie zewnętrznych zasób jako wewnętrzne w systemie, ale i bez tego
 komunikacja z innymi systemami jest przejrzysta.
 Ponadto przybliża to marzenie Suna o globalnej sieci, jako jednym wielkim
 komputerze.
\end_layout

\begin_layout Subsection
Narzędzia wykorzystane w pracy
\end_layout

\begin_layout Standard
Poniżej zamieszczony jest krótki opis poszczególnych technologii, użytych
 w części praktycznej, czyli języka Ruby, oraz środowiska rozwoju aplikacji
 Ruby on Rails.
 Następnie dokładnie zostanie omówiona kwestia środowiska wspierającego
 przygotowanie testów - RSpec i biblioteka uruchamiają opowieści użytkownika
 w formacie tekstowym Cucumber.
\end_layout

\begin_layout Subsubsection
Ruby
\end_layout

\begin_layout Standard
Jest to język opracowany w połowie lat dziewięćdziesiątych, przez Yukihiro
 Matsumoto
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Yukihro Matsumoto jest często nazywany wśród ludzi związanych z rubym jako
 'matz'.
\end_layout

\end_inset

.
 Chciał stworzyć język w którym znalazłoby się miejsce dla wybranych cech
 takich języków jak Perl, Smalltalk, Eiffel, Ada i Lisp.
 Miał to być balans, pomiędzy programowaniem funkcyjnymi, a programowaniem
 imperatywnym.
 Pierwszy publiczne wydanie nastąpiło w 1995 roku.
 Ogromny wzrost popularności w ostatnich latach, zawdzięcza on, rozwojowi
 aplikacji Ruby on Rails.
 To zaś zaowocowało dużą społecznością, która znalazła jeszcze inne zastosowania
 tego języka.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Jako przykład może posłużyć powłoka systemowa - które może być użyte jako
 zamiennik dla basha - w której posługujemy się językiem Ruby, nazywa się
 rush(http://rush.heroku.com).
 Warto nadmienić że wiele skryptów dla systemów *nix, również jest już pisane
 w tym języku.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Główne cechy języka
\end_layout

\begin_layout Itemize
wszystko jest obiektem (liczba, napis tekstowy)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Wyjątek stanowi tu referencja do obiektu
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
elastyczna składnia
\end_layout

\begin_layout Itemize
wsparcie dla bloków kodu
\end_layout

\begin_layout Itemize
mixiny, które w naturalny sposób rozwiązują problem wielodziedziczenia
\end_layout

\begin_layout Itemize
obsługa błędów przez wyjątki
\end_layout

\begin_layout Itemize
garbage collector
\end_layout

\begin_layout Subsubsection
Ruby on Rails
\end_layout

\begin_layout Standard
Jest to środowisko, które umożliwia szybki rozwoj aplikacji webowych opartych
 na bazach danych.
 Środowisko to, bardzo szybko się rozwija, dzięki dużej społeczności zaangażowan
ej w projekt.
 Ruby on Rails
\begin_inset CommandInset citation
LatexCommand cite
key "RoR.homepage"

\end_inset

 powstał poprzez wyciągniecie go z projektu BaseCamp w 2004 roku przez Davida
 Heinemeiera Hanssona.
 Od tego czasu rozwija się bardzo prężnie, zwłaszcza na przełomie ostatnich
 dwóch lat.
\end_layout

\begin_layout Paragraph
Zalety środowiska
\end_layout

\begin_layout Itemize
narzucony wzorzec MVC
\end_layout

\begin_layout Itemize
bardzo dobre wsparcie dla REST'a
\end_layout

\begin_layout Itemize
abstrakcyjny mapper bazy danych ActiveRecord
\end_layout

\begin_layout Itemize
rozbudowane wsparcie dla testów (TestUnit, RSpec-on-rails, Cucumber)
\end_layout

\begin_layout Itemize
mnóstwo pluginów
\begin_inset CommandInset citation
LatexCommand cite
key "RoR.plugins"

\end_inset

, wraz ze wsparciem do wydzielania części systemu
\end_layout

\begin_layout Subsubsection
RSpec
\end_layout

\begin_layout Standard
Jedno z założeń BDD wiąże się z automatyzacją testów w aplikacji.
 Aby osiągnąć to w efektywny sposób, potrzebny jest dedykowany język
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Domain specific language (DSL)
\end_layout

\end_inset

, dla tego konkretnego zadania.
 Pierwsze wzmianki na temat powstania języka Ruby taki DSL, przedstawił
 Dave Astel
\begin_inset CommandInset citation
LatexCommand cite
key "DaveAstel.Blog"

\end_inset

 w artykule 'Nowe Spojrzenie na TDD'
\begin_inset CommandInset citation
LatexCommand cite
key "BDD.RSPEC.FirstIntroduction"

\end_inset

z 2005 roku.
 Zwrócił on uwagę na zbudowanie takiego DSL'a, który będzie wspierał opis
 zachowania wraz z weryfikacją tego zachowania.
 Zaproponował kilka zmian związanych z nazewnictwem, zamiast zaczynać nazwy
 metod od słowa 'test', zacząć od słowa 'should', używać słowa 'Context'
 zamiast 'TestCase' oraz 'shouldBe' w zamian 'assert'.
 Celem takich zabiegów, było położenie nacisku na testowanie zachowania.
 Poniżej jest umieszczony przykład zaczerpnięty z artykuły 'Wstęp do BDD'
\begin_inset CommandInset citation
LatexCommand cite
key "RSPEC.BDD.DaveAstel.Intro"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/code/Rspec.Dave.Astel.First.Example.png
	clip

\end_inset


\end_layout

\begin_layout Standard
Przez okres ostatnich 3 lat, framework przeszedł wiele modyfikacji i usprawnień.
 Dzięki pracy wielu osób
\begin_inset CommandInset citation
LatexCommand cite
key "RSPEC.community,RSPEC.commit.history"

\end_inset

, formalny zapis testów jest jeszcze bardziej przejrzysty i intuicyjny.
 Gdyby uaktualnić przykład zamieszczony powyżej, biorąc pod uwagę aktualną
 specyfikację frameworka, będzie on miał postać zbliżoną do zamieszczonej
 poniżej.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/code/Rspec.Dave.Astel.First.Example.update.png

\end_inset


\end_layout

\begin_layout Standard
Tak napisany spec
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Zamiast używać słowa test, Astel zaczął nazywać taką weryfikację 'spec',
 prawdopodobnie od angielskiego słowa specyfication
\end_layout

\end_inset

 ma dużo większy wpływ na postrzeganie zachowania systemu, który chcemy
 weryfikować.
 Jest to również wielce pomocne przy generowanie raportów, które notabene
 są pewną formą dokumentacji systemu - opisują jego pożądane zachowanie.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/report/rspec.png

\end_inset


\end_layout

\begin_layout Standard
Aktualnie liderem projektu jest David Chelimsky
\begin_inset CommandInset citation
LatexCommand cite
key "DavidChelimsky.Blog"

\end_inset

.
 Ah Astel ciągle jest aktywny w projekcie, zwłaszcza w promowaniu metodologi
 BDD.
 Sam Rspec nie doczekał się jeszcze żadnej książki, która zebrała by informacje
 na temat BDD, RSpec i Cucumber.
 W planach jest wydanie takiej książki
\begin_inset CommandInset citation
LatexCommand cite
key "RSPEC.the.book"

\end_inset

 w kwietniu 2009 roku.
 Będzie to praca zbiorowa Chelimskiego, Astela, Norhta, Dennisa
\begin_inset CommandInset citation
LatexCommand cite
key "Zach.Denis.Blog"

\end_inset

, Hellesoya
\begin_inset CommandInset citation
LatexCommand cite
key "Aslak.Hellesoy.Blog"

\end_inset

 i Helmkampa
\begin_inset CommandInset citation
LatexCommand cite
key "Bryan.Helmkapm.Blog"

\end_inset

.
 Biorąc pod uwagę autorów, będzie to z pewnością pozycja, z którą warto
 się zapoznać.
\end_layout

\begin_layout Subsubsection
Cucumber
\end_layout

\begin_layout Standard
Idealnym rozwiązaniem byłaby możliwość pisania testów integracyjnych przez
 osoby, które nie są programistami, a które mogłyby powtarzalnie weryfikować
 system.
 Niestety nie jest to w pełni osiągalne.
 Pewnym postępem w tym kierunku, jest tworzenie tekstowych opowieści użytkownika
, z wydzielonymi scenariuszami, które są zrozumiałe dla ludzi biznesu.
 Jedną z najciekawszych implementacji jest Cucumber.
\end_layout

\begin_layout Standard
Jego historia zaczyna się od pierwszej próby - dla rspec'a - którą był RBehave
\begin_inset CommandInset citation
LatexCommand cite
key "RSPEC.rbehave.introduction"

\end_inset

, napisany przez Northa w 2006 roku.
 Niestety nie było to jeszcze czymś akceptowalnym dla klienta biznesowego.
 Kolejnym krokiem był Story Runner
\begin_inset CommandInset citation
LatexCommand cite
key "Cucumber.StoryRunnerInPlainText"

\end_inset

, nad którym pracował Astel, we współpracy z Northem - pierwsza wersja była
 dostępna w drugiej połowie 2007 roku.
 Projekt bazował na wcześniejszym RBehave, jednak jego największym sukcesem,
 była możliwość uruchamiania, z pliku tekstowego, opowieści użytkownika
 napisanych po angielsku.
 Początkiem kwietnia 2008 roku, Aslak Hellesoy rozpoczął prace nad nowym
 środowiskiem do uruchamiania opowieści użytkownika z czystego pliku, a
 projekt został ostatecznie nazwany Cucumber (pierwotnie nazywał się Stories).
 Po zaledwie pięciu miesiącach prac, został on zamiennikiem dla Story Runner
\begin_inset CommandInset citation
LatexCommand cite
key "Cucumber.replacement.of.story.runner"

\end_inset

.
 Chelimsky zmianę tę uargumentował tym, że Cucumber posiada większą ilość
 funkcjonalności, i jest prostszy w konfiguracji.
 Poniżej wymienione są jego cechy.
\end_layout

\begin_layout Itemize
gramatyczny parser opowieści użytkownika w postaci tekstowej
\end_layout

\begin_layout Itemize
pozwala pisać opowieści użytkownika w ponad 20 językach (również po polsku)
\end_layout

\begin_layout Itemize
lepsze śledzenie błędu (od story runnera)
\end_layout

\begin_layout Itemize
prosta konfiguracja (od story runnera)
\end_layout

\begin_layout Itemize
warunkowa kontynuacja kroku
\end_layout

\begin_layout Standard
Historyjki są pisane w języku dedykowanym, którego struktura umożliwia jednoznac
zne zrozumienie w świecie biznesu - język ten nazywa się Gherkin
\begin_inset CommandInset citation
LatexCommand cite
key "Cucumber.Gherkin"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Gherkin to po angielsku mały ogórek
\end_layout

\end_inset

.
 To właśnie ten moduł odpowiada za wsparcie dla wielu języków
\begin_inset CommandInset citation
LatexCommand cite
key "Cucumber.Gherkin.spokenlanguege"

\end_inset

.
 Możliwe jest również dodawanie nowych modułów, lub adaptacji dla własnych
 potrzeb, już istniejących.
 Sam język posiada niewielką gamę słów kluczowych
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
w nawiasach podane angielskie odpowiedniki
\end_layout

\end_inset

: 
\end_layout

\begin_layout Itemize
Właściwość (Feature) - określa jaką właściwość opisujemy
\end_layout

\begin_layout Itemize
Scenariusz (Scenario) - opisuje konkretny scenariusz działania użytkownika
\end_layout

\begin_layout Itemize
Dane (Given) - określa dane wejściowe (np: użytkownika znajduje się w widoku
 systemu; użytkownik jest zalogowany)
\end_layout

\begin_layout Itemize
Jeżeli (When) - zwraca uwagę na czynności które podejmuje użytkownik
\end_layout

\begin_layout Itemize
Wtedy (Then) - określa pożądany efekt końcowy
\end_layout

\begin_layout Itemize
Oraz (And) - łączy kroki w sekcjach (Dane, Jeżeli, Wtedy)
\end_layout

\begin_layout Standard
Poniżej zamieszczony jest przykład.
\end_layout

\begin_layout Quote
\begin_inset Graphics
	filename images/stories/feature.example.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Wspomaganie procesu produkcji oprogramowania
\end_layout

\begin_layout Standard
Jak zostało wspomniane na początku, metodologie agile nie są związane z
 konkretną technologią, czy też narzędziem, jednakże bardzo proste narzędzia
 potrafią usprawnić ten proces.
 Taki też cel jest postawiony przed tym narzędziem - ma wspomagać proces
 agregowania wymagań od klienta, ułatwiać pisanie dokumentacji dla projektów,
 oraz analizy wykonanej pracy, względem tej wyznaczonej.
 Od strony developerów ma ponadto ułatwiać pisanie automatycznych testów.
\end_layout

\begin_layout Standard
Potrzeba powstania takiego narzędzia, była efektem współpracy z klientami,
 którzy często zmieniali wymagania dotyczące projektów, czy też dokładali
 mnóstwo pracy w trakcie realizacji zadań.
 Było to powodem wielu problemów i komplikacji względem rozliczania pracy
 wykonanej, gdyż nie było dobrego sposobu śledzenia zmian.
 
\end_layout

\begin_layout Standard
Kwestią drugą, był problem związanym z brakiem automatycznych testów.
 Powodowało to częste problemy, które pojawiały się najczęściej tuż po przekazan
iu kodu do produkcji.
 To uzmysłowiło jak ważne jest posiadanie testów integracyjnych.
 
\end_layout

\begin_layout Standard
Środowisko Cucumber do uruchamiania opowieści tekstowych, na podstawie których
 weryfikowane jest zachowanie systemu, jest w tym przypadku idealnym rozwiązanie
m.
 Dodając do tego intuicyjny interfejs tworzenia takich opowieści, dzięki
 któremu klienci sami by mogli wprowadzać te informacje, zaczyna to wyglądać
 coraz bardziej interesująco.
 Uzupełnieniem powyższych zalet jest możliwość śledzenia zmian.
 Gdy weźmiemy te trzy na pozór proste właściwości, otrzymamy wartościowe
 narzędzie dla developerów.
\end_layout

\begin_layout Subsection
Specyfikacja funkcjonalna
\end_layout

\begin_layout Standard
Poniżej zostanie zwrócona uwaga na główne właściwości projektu, oraz cele,
 które są ważne dla realizacji tego projektu
\end_layout

\begin_layout Subsubsection
Opowieści użytkownika
\end_layout

\begin_layout Standard
Jest to w zasadzie trzon całej aplikacji.
 O samej wartości opowieści użytkownika dużo powiedziano w sekcjach poświęconych
 BDD i Cucumber.
 Zalety opowieści w postaci czystego tekstu są ogromne, jednakże czasem
 potrzeba jest manipulacja prowadzona na tych danych, jak na przykład eksport
 do dokumentacji ładnie sformatowanych opowieści.
 Kolejną istotną kwestią jest wygoda wprowadzania tych opowieści.
 Developerzy lubią specyficzne
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Przykładem może być vi(m) czy też emacs.
\end_layout

\end_inset

 edytory tekstowe, jednakże inni preferują dostosowane interfejsy, i właśnie
 dla nich to narzędzie będzie użyteczne.
\end_layout

\begin_layout Subsubsection
Śledzenie zmian
\end_layout

\begin_layout Standard
Wielokrotnie była już zwrócona uwaga na sposób traktowania zmiany w metodologiac
h zwinnych, które są mile widziane na każdym etapie prac.
 Chociaż klienci bardzo chętnie te zmiany wprowadzają, to już trudniej im
 wszystkie modyfikacje spamiętać.
 Nie zawsze są świadomi jak bardzo ich pierwotna wizja różni się od wersji
 końcowej.
 Możliwość wykazania tych zmian w przejrzysty sposób, daje dwie korzyści.
 Po pierwsze, klient może zobaczyć jak proces, w którym bierze aktywny udział
 wpływa na poprawę jakości produktu.
 Drugą sprawą są kwestie finansowe: taki raport, to solidny argument dla
 negocjatorów.
\end_layout

\begin_layout Standard
Ważne jest tutaj śledzenie zmian, ze względu na konkretną właściwość systemu,
 oraz ze względu na wydzielony okres czasu.
\end_layout

\begin_layout Subsubsection
Eksport opowieści użytkownika
\end_layout

\begin_layout Standard
Przechowując dane o odpowiedniej strukturze, mamy możliwość zautomatyzowania
 procesów monotonnych, poprzez prezentacje danych w innych formatach.
\end_layout

\begin_layout Paragraph
Cucumber
\end_layout

\begin_layout Standard
Ten format jest sztandarowy dla tego projektu.
 Dzięki eksportowaniu do niego danych, zautomatyzowany zostaje proces tworzenia
 plików dla poszczególnych właściwości.
 Dzięki temu, zmiany w specyfikacji, można szybko aktualizować dla systemu
 automatycznych testów.
\end_layout

\begin_layout Paragraph
PDF
\end_layout

\begin_layout Standard
Potrzeba tworzenia dokumentacji technicznej systemu implementowanego jest
 bardzo ważna.
 Gdy weźmiemy pod uwagę fakt, że opowieści użytkownika to świetna dokumentacja,
 to automatyczne utworzenie dokumentu pdf ze wszystkimi właściwościami,
 docenią wszyscy - nawet ci, którzy lubią pisać dokumentacje.
\end_layout

\begin_layout Subsection
Implementacja narzędzia
\end_layout

\begin_layout Standard
Opowieści użytkownika zostały zapisana za pomoca trzech modeli: 'Feature',
 'Scenario', 'ScenarioStep'.
 Pokrótce zotaną teraz opisane.
 Ponadto poniżej znajduje się również diagram modeli, oraz digram klas.
 
\end_layout

\begin_layout Standard
Feature - właściwość przechowuje tytuł opowieści, powód wprowadzenia, kto
 będzie z niego korzystał, oraz krótkie sformułowanie co dana funkcjonalność
 wnosi do systemu (co użytkownik może).
 Agreguje on również scenariusze.
 
\end_layout

\begin_layout Standard
Scenario - scenariusz przechowuje tylko tytuł, oraz agreguje główne typy
 kroków - są kroki takie jak 'Dane', 'Jeżeli', 'Wtedy'.
 
\end_layout

\begin_layout Standard
ScenarioStep - krok scenariusza, posiada typ, oraz instrukcje.
 Typy główne zostały wymienione wcześniej, mozliwe podtypy które sa agregowane
 przez krok główny to 'ale', 'oraz'.
\end_layout

\begin_layout Standard
Ważnym elementem systemu jest funkcjonalność dzięki której możliwy jest
 monitoring zmian które są dokonywane na obiektach typu 'Feature', 'Scenario'
 oraz 'ScenarioStep'.
 Dzieki czemu nie jest problemem określenie kto danej zmiany dokonał, a
 jest to ważne jak zostało to już wcześniej wyjaśnione.
 
\end_layout

\begin_layout Standard
Wprowadzenie zmiany polega, tak jak zawsze na nadpisaniu atrybutów, jednak
 zanim nastąpi zapis na medium trwałe - w tym przypadku bazę danych - następuje
 kopiowanie atrybutów, które uległy zmianie, jest to możliwe dzięki pobraniu
 aktualnych wartości z bazy.
 Dla każdego zmienionego atrybutu tworzony jest obiekt typu Audit.
 Zapisywane jest w nim wartość atrybut przed zmianą i po, wraz z informacją
 o użytkowniku który tej zmiany dokonał.
 Przechowywana jest również informacja o obiekcie oraz atrybucie dla którego
 audyt jest wykonywany.
 Powiązanie między audytem a różnymi modelami jest możliwe dzieki polimorficznem
u powiązaniu.
 Wszystkie klucze które są reprezentowane przez ciąg znaków - nazwa modelu,
 atrybutu - są mapowane na wartości liczbowe całkowite, dzięki czemu osiągany
 jest zysk na ładowaniu danych z bazy i przesyłaniu tych danych za pośrednictwem
 sieci, dodatkowym atutem jest mniejsza ilośc wykorzystywanej pamięci operacyjne
j która jest niezbędna przy operacjach na dużych zbiorach danych.
 Przykładowe fragment kodu który trigeruje, zapis zmian dla czterech atrybutów
 klasy Feature, jest ukazany poniżej.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/code/Audit.Methods.png
	width 95text%

\end_inset


\end_layout

\begin_layout Subsubsection
Diagram Modeli
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/diagrams/models.png
	width 75page%

\end_inset


\end_layout

\begin_layout Subsubsection
Diagram Kontrolerów
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename images/diagrams/controllers.png
	width 75page%

\end_inset


\end_layout

\begin_layout Subsubsection
Diagram Bazy Danych
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Prezentacja aplikacji
\end_layout

\begin_layout Standard
Celem przy tworzeniu tej aplikacji jest aby użytkowanie jej było intuicyjne
 i proste, co w pewnej mierze sie udało.
\end_layout

\begin_layout Subsection
ekran powitalny
\end_layout

\begin_layout Subsubsection
logowania
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/001_logowanie.png
	width 95text%

\end_inset


\end_layout

\begin_layout Subsubsection
tworzenie nowego konta
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/002_tworzenie_konta.png

\end_inset


\end_layout

\begin_layout Subsubsection
odzyskiwanie hasła
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/003_odzyskanie_hasla.png

\end_inset


\end_layout

\begin_layout Subsection
lista właściwości
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/008_lista_wlasciwosci.png
	width 95text%

\end_inset


\end_layout

\begin_layout Subsubsection
tworzenie właściwości
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/004_tworzenie_wlasciwosci.png
	width 95text%

\end_inset


\end_layout

\begin_layout Subsection
widok właściwości
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/005_strona_wlasciwosci.png

\end_inset


\end_layout

\begin_layout Subsubsection
dodawanie scenariusza
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/004_tworzenie_scenariusza.png
	width 95text%

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename images/screenshots/004_tworzenie_scenariusza_01.png
	width 95text%

\end_inset


\end_layout

\begin_layout Subsubsection
edycja
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/009_edition_1.png

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename images/screenshots/009_edition_2.png

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename images/screenshots/009_edition_3.png

\end_inset


\end_layout

\begin_layout Subsubsection
eksport
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename images/screenshots/006_export_cucumber.png
	width 95text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Podsumowanie
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "AlanCooper.every.7.years"

\end_inset

 Alan Cooper - The Wisdom of Experience
\begin_inset Newline newline
\end_inset

http://www.cooper.com/journal/agile2008 - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "AgileManifesto"

\end_inset

Agile Manifesto - official webpage
\begin_inset Newline newline
\end_inset

http://agilemanifesto.org/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "AgileManifesto.Authors"

\end_inset

Agile Manifesto - Authors
\begin_inset Newline newline
\end_inset

http://agilemanifesto.org/authors.html - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "AgileManifesto.Principles"

\end_inset

Principles behind the Agile Manifesto
\begin_inset Newline newline
\end_inset

http://agilemanifesto.org/principles.html- 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "AgileManifesto.Tlumaczenie"

\end_inset

Tłumaczenie Agile Manifest
\begin_inset Newline newline
\end_inset

http://pl.wikipedia.org/wiki/Manifest_Agile - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Ruby.homepage"

\end_inset

Oficjalna strona języka Ruby
\begin_inset Newline newline
\end_inset

http://www.ruby-lang.org/pl/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RoR.homepage"

\end_inset

Oficjalna strona frameworku Ruby on Rails
\begin_inset Newline newline
\end_inset

http://www.rubyonrails.pl/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Rspec.homepage"

\end_inset

Oficjalna strona fremeworku Rspec
\begin_inset Newline newline
\end_inset

http://rspec.info - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Remarkable.wiki"

\end_inset

Wiki biblioteki Remarkable
\begin_inset Newline newline
\end_inset

http://wiki.github.com/carlosbrando/remarkable - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "DRY.Interview.With.Dave.Thomas"

\end_inset

Bill Venners - Orthogonality and the DRY Principle
\begin_inset Newline newline
\end_inset

http://www.artima.com/intv/dry.html - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "MVC.Author.Report"

\end_inset

Trygve Reenskaug - The original MVC reports Trygve Reenskaug Dept.
 of Informatics University of Oslo
\begin_inset Newline newline
\end_inset

http://heim.ifi.uio.no/~trygver/2007/MVC_Originals.pdf - 13.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "MVC.pattern.describe"

\end_inset

Interactive Application Architecture Patterns 
\begin_inset Newline newline
\end_inset

http://ctrl-shift-b.blogspot.com/2007/08/interactive-application-architecture.html
 - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.Author.Introduction"

\end_inset

IDan North - ntroducing BDD
\begin_inset Newline newline
\end_inset

http://dannorth.net/introducing-bdd - 17.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.info"

\end_inset

Dan North - Oficjlna strona o BDD
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.AllAboutBehaviour"

\end_inset

Dan North - BDD - It's All Behaviour
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/ItsAllBehaviour - 17.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.BusinessValue"

\end_inset

Dan North - BDD - Where's The Business Value
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/WheresTheBusinessValue - 17.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.EnoughIsEnough"

\end_inset

Dan North - BDD - Enough Is Enough
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/EnoughIsEnough - 17.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.Stories"

\end_inset

Dan North - BDD - Stories
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/Story - 18.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.BehaviourDrivenPrograming"

\end_inset

Dan North - BDD - Behaviour Driven Programming
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/BehaviourDrivenProgramming
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.GettingTheWordsRight"

\end_inset

Dan North - BDD - Getting The Words Right
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/GettingTheWordsRight - 17.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.CostOfChange"

\end_inset

Dan North - BDD - Cost Of Change
\begin_inset Newline newline
\end_inset

http://behaviour-driven.org/CostOfChange - 17.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "DaveAstel.Blog"

\end_inset

Dave Astel - Blog
\begin_inset Newline newline
\end_inset

http://blog.daveastels.com - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "DavidChelimsky.Blog"

\end_inset

David Chelimsky - Blog
\begin_inset Newline newline
\end_inset

http://blog.davidchelimsky.net - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BDD.RSPEC.FirstIntroduction"

\end_inset

Dave Astel - A New Look at Test Driven Development
\begin_inset Newline newline
\end_inset

http://techblog.daveastels.com/2005/07/05/a-new-look-at-test-driven-development
 - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RSPEC.BDD.DaveAstel.Intro"

\end_inset

Dave Astel - BDD Intro
\begin_inset Newline newline
\end_inset

http://techblog.daveastels.com/files/BDD_Intro.pdf - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RSPEC.community"

\end_inset

Rspec Core Team - Contribute
\begin_inset Newline newline
\end_inset

http://rspec.info/community - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RSPEC.commit.history"

\end_inset

github - Rspec Commits History
\begin_inset Newline newline
\end_inset

http://github.com/dchelimsky/rspec/commits/master - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RSPEC.rbehave.introduction"

\end_inset

Dan North - Introducting rbehave
\begin_inset Newline newline
\end_inset

http://dannorth.net/2007/06/introducing-rbehave - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Zach.Denis.Blog"

\end_inset

Zach Denis - Blog
\begin_inset Newline newline
\end_inset

http://continuousthinking.com - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Aslak.Hellesoy.Blog"

\end_inset

Aslak Hellesoy - Blog
\begin_inset Newline newline
\end_inset

http://blog.aslakhellesoy.com - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Bryan.Helmkapm.Blog"

\end_inset

Bryan Helmkamp - Blog
\begin_inset Newline newline
\end_inset

 http://www.brynary.com/
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RSPEC.the.book"

\end_inset

The Pragmatic Programmer -The RSpec Book: Behaviour Driven Development with
 Ruby
\begin_inset Newline newline
\end_inset

http://www.pragprog.com/titles/achbd/the-rspec-book - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Cucumber.StoryRunnerInPlainText"

\end_inset

David Chelimsky - Story Runner in Plain English
\begin_inset Newline newline
\end_inset

http://blog.davidchelimsky.net/articles/2007/10/21/story-runner-in-plain-english
 - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Cucumber.Gherkin.spokenlanguege"

\end_inset

 Aslak Hellesoy - Cucumber spoken languages
\begin_inset Newline newline
\end_inset

http://github.com/aslakhellesoy/cucumber/blob/master/lib/cucumber/languages.yml
 - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Cucumber.Gherkin"

\end_inset

Aslak Hellesoy - Cucumber: Gherkin
\begin_inset Newline newline
\end_inset

http://wiki.github.com/aslakhellesoy/cucumber/gherkin - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Cucumber.wiki"

\end_inset

Oficjalna strona Cucumber
\begin_inset Newline newline
\end_inset

http://cukes.info/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Cucumber.replacement.of.story.runner"

\end_inset

David Chelimsky - Cucumber
\begin_inset Newline newline
\end_inset

 http://blog.davidchelimsky.net/2008/9/22/cucumber - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "ProgramingByBusinnessPeople"

\end_inset

Martin Fowler - Will DSLs allow business people to write software rules
 without involving programmers?
\begin_inset Newline newline
\end_inset

http://martinfowler.com/bliki/BusinessReadableDSL.html - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Ruby.about.language"

\end_inset

Społeczność ruby - o Języku Ruby
\begin_inset Newline newline
\end_inset

http://www.ruby-lang.org/pl/about - 23.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "REST.roy.t.fielding.homepage"

\end_inset

Roy T.
 Fielding - Strona domowa
\begin_inset Newline newline
\end_inset

http://roy.gbiv.com/
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "REST.author.explenation"

\end_inset

Roy Thomas Fielding - Architectural Styles and the Design of Network-based
 Software Architectures - Roy Thomas Fielding
\begin_inset Newline newline
\end_inset

CHAPTER 5 Representational State Transfer (REST)
\begin_inset Newline newline
\end_inset

http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "ApacheFoundation"

\end_inset

The Apache Software Foundation
\begin_inset Newline newline
\end_inset

http://www.apache.org/
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Waterfall.introduction"

\end_inset

Royce W.W.
 - Managing the Development of Large Software Systems
\begin_inset Newline newline
\end_inset

http://www.cs.umd.edu/class/spring2003/cmsc838p/Process/waterfall.pdf - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "SpiralModel.introduction"

\end_inset

Boehm B.
 - A Spiral Model of Software Development and Enhancement
\begin_inset Newline newline
\end_inset

http://www.cs.usu.edu/~supratik/CS%205370/r5061.pdf - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "NBehave"

\end_inset

NBehave
\begin_inset Newline newline
\end_inset

http://code.google.com/p/nbehave/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "NSpec"

\end_inset

NSpec
\begin_inset Newline newline
\end_inset

http://nspec.tigris.org/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "NSpecify"

\end_inset

NSpecify
\begin_inset Newline newline
\end_inset

http://nspecify.sourceforge.net/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "NUnit"

\end_inset

Nunit
\begin_inset Newline newline
\end_inset

http://www.nunit.org - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "instinct"

\end_inset

Instinct
\begin_inset Newline newline
\end_inset

http://code.google.com/p/instinct/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JBehave"

\end_inset

JBehave
\begin_inset Newline newline
\end_inset

http://jbehave.org/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "JDave"

\end_inset

JDave
\begin_inset Newline newline
\end_inset

http://www.jdave.org/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Jspec"

\end_inset

JSpec
\begin_inset Newline newline
\end_inset

http://wiki.github.com/visionmedia/jspec - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "CSpec"

\end_inset

CSpec
\begin_inset Newline newline
\end_inset

http://wiki.github.com/arnaudbrejeon/cspec/home - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Specs"

\end_inset

Specs
\begin_inset Newline newline
\end_inset

http://code.google.com/p/specs/ - 10.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "There.is.no.silver.bullet"

\end_inset

 Fred Brooks - No Silver Bullet - Essence and Accidents of Software Engineering
\begin_inset Newline newline
\end_inset

http://www.lips.utexas.edu/ee382c-15005/Readings/Readings1/05-Broo87.pdf - 24.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "WaterfallDoesntWork"

\end_inset

Tarmo Toikkanen - Don’t draw diagrams of wrong practices - or: Why people
 still believe in the Waterfall model
\begin_inset Newline newline
\end_inset

http://tarmo.fi/blog/2005/09/09/dont-draw-diagrams-of-wrong-practices-or-why-peop
le-still-believe-in-the-waterfall-model/ - 24.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "You.not.gonna.need.it"

\end_inset

Ronald E Jeffries - You’re NOT gonna need it!
\begin_inset Newline newline
\end_inset

http://www.xprogramming.com/Practices/PracNotNeed.html - 24.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "scrum.10.steps"

\end_inset

Agile Software - How To Implement Scrum In 10 Easy Steps
\begin_inset Newline newline
\end_inset

http://www.agile-software-development.com/2007/09/how-to-implement-scrum-in-10-eas
y-steps.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RoR.plugins"

\end_inset

Agile Web Development - Zbiór pluginów dla Railsów
\begin_inset Newline newline
\end_inset

http://agilewebdevelopment.com/plugins - 24.01.2009
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "SCRUM.what.i.learned"

\end_inset

Jeff Sutherland - What i have learned from first Scrum
\begin_inset Newline newline
\end_inset

http://jeffsutherland.com/scrum/FirstScrum2004.pdf
\end_layout

\end_body
\end_document
